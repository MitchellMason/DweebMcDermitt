//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;

namespace PosterGen
{
	public static class MeshUtils{

		public static void calculateMeshTangents(Mesh mesh)
		{
			//speed up math by copying the mesh arrays
			int[] triangles = mesh.triangles;
			Vector3[] vertices = mesh.vertices;
			Vector2[] uv = mesh.uv;
			Vector3[] normals = mesh.normals;
			
			//variable definitions
			int triangleCount = triangles.Length;
			int vertexCount = vertices.Length;
			
			Vector3[] tan1 = new Vector3[vertexCount];
			Vector3[] tan2 = new Vector3[vertexCount];
			
			Vector4[] tangents = new Vector4[vertexCount];
			
			for (long a = 0; a < triangleCount; a += 3)
			{
				long i1 = triangles[a + 0];
				long i2 = triangles[a + 1];
				long i3 = triangles[a + 2];
				
				Vector3 v1 = vertices[i1];
				Vector3 v2 = vertices[i2];
				Vector3 v3 = vertices[i3];
				
				Vector2 w1 = uv[i1];
				Vector2 w2 = uv[i2];
				Vector2 w3 = uv[i3];
				
				float x1 = v2.x - v1.x;
				float x2 = v3.x - v1.x;
				float y1 = v2.y - v1.y;
				float y2 = v3.y - v1.y;
				float z1 = v2.z - v1.z;
				float z2 = v3.z - v1.z;
				
				float s1 = w2.x - w1.x;
				float s2 = w3.x - w1.x;
				float t1 = w2.y - w1.y;
				float t2 = w3.y - w1.y;
				
				float r = 1.0f / (s1 * t2 - s2 * t1);
				
				Vector3 sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
				Vector3 tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
				
				tan1[i1] += sdir;
				tan1[i2] += sdir;
				tan1[i3] += sdir;
				
				tan2[i1] += tdir;
				tan2[i2] += tdir;
				tan2[i3] += tdir;
			}
			
			
			for (long a = 0; a < vertexCount; ++a)
			{
				Vector3 n = normals[a];
				Vector3 t = tan1[a];
				
				//Vector3 tmp = (t - n * Vector3.Dot(n, t)).normalized;
				//tangents[a] = new Vector4(tmp.x, tmp.y, tmp.z);
				Vector3.OrthoNormalize(ref n, ref t);
				tangents[a].x = t.x;
				tangents[a].y = t.y;
				tangents[a].z = t.z;
				
				tangents[a].w = (Vector3.Dot(Vector3.Cross(n, t), tan2[a]) < 0.0f) ? -1.0f : 1.0f;
			}
			
			mesh.tangents = tangents;
		}

		public static Mesh makeMesh(string name, Vector3 [] verts, Vector2[] uvs, int[] inds)
		{
			Mesh mesh = new Mesh();
			mesh.name = name;
			mesh.Clear();
			
			mesh.vertices = verts;
			mesh.uv = uvs;
			mesh.triangles = inds;
			
			mesh.Optimize();

			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			calculateMeshTangents(mesh);
			return mesh;
		}
		public static GameObject createObjFrame(Mesh mesh, Texture2D tex, Shader ShaderToUse,
		                                   List<string> textureNames, List<Texture2D> texturesToUse,
		                                   float scalemaps)
		{
			GameObject obj = new GameObject(mesh.name, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider));
			MeshFilter mf = (MeshFilter)obj.gameObject.GetComponent(typeof(MeshFilter));
			
			MeshRenderer mr = (MeshRenderer)obj.gameObject.GetComponent(typeof(MeshRenderer));
			
			Material m = new Material(ShaderToUse);
			
			mr.renderer.material = m;

			for (int i = 0; i < textureNames.Count; ++i)
			{
				if (texturesToUse[i].width > 1 || texturesToUse[i].height > 1)
				{
					mr.renderer.sharedMaterial.SetTexture(textureNames[i], texturesToUse[i]);
					mr.renderer.sharedMaterial.SetTextureScale(textureNames[i], new Vector2(scalemaps,scalemaps));
				}
			} 
			
			mf.mesh = mesh;
			
			
			MeshCollider  col = (MeshCollider)obj.gameObject.GetComponent(typeof(MeshCollider));
			
			col.sharedMesh = mesh;//
			return obj;
		}
		public static GameObject createObj(Mesh mesh, Texture2D tex, Shader ShaderToUse,
		                            List<string> textureNames, List<Texture2D> texturesToUse,
		                            float scalemaps, Vector2 scaler)
		{
			GameObject obj = new GameObject(mesh.name, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider));
			MeshFilter mf = (MeshFilter)obj.gameObject.GetComponent(typeof(MeshFilter));
			
			MeshRenderer mr = (MeshRenderer)obj.gameObject.GetComponent(typeof(MeshRenderer));
			
			Material m = new Material(ShaderToUse);
			
			mr.renderer.material = m;
			
			mr.renderer.sharedMaterial.SetTexture("_MainTex",tex);
			for (int i = 0; i < textureNames.Count; ++i)
			{
				if (textureNames[i] == "_MainTex")
					continue;
				if (texturesToUse[i].width > 1 || texturesToUse[i].height > 1)
				{
					mr.renderer.sharedMaterial.SetTexture(textureNames[i], texturesToUse[i]);
					mr.renderer.sharedMaterial.SetTextureScale(textureNames[i], new Vector2(scalemaps*(scaler.x*2.0f),scalemaps*(scaler.y*2.0f)));
				}
			} 
			
			mf.mesh = mesh;
			
			
			MeshCollider  col = (MeshCollider)obj.gameObject.GetComponent(typeof(MeshCollider));
			
			col.sharedMesh = mesh;//
			return obj;
		}
		
		public static Mesh convertTexToMesh(Vector2 scaler, string name)
		{
			Vector3 [] verts = new Vector3[8];
			Vector2 [] uvs = new Vector2[8];
			int[] inds = new int[12];
			inds[0] = 2;
			inds[1] = 1;
			inds[2] = 0;
			inds[3] = 0;
			inds[4] = 3;
			inds[5] = 2;
			inds[6] = 0+4;
			inds[7] = 1+4;
			inds[8] = 2+4;
			inds[9] = 2+4;
			inds[10] = 3+4;
			inds[11] = 0+4;
			
			uvs[0] = new Vector2(0,0);
			uvs[1] = new Vector2(0,1);
			uvs[2] = new Vector2(1,1);
			uvs[3] = new Vector2(1,0);
			
			
			
			
			verts[0] = new Vector3(-scaler.x,-scaler.y,0);
			verts[1] = new Vector3(-scaler.x,scaler.y,0);
			verts[2] = new Vector3(scaler.x,scaler.y,0);
			verts[3] = new Vector3(scaler.x,-scaler.y,0);
			
			
			
			uvs[4] = new Vector2(0,0);
			uvs[5] = new Vector2(0,1);
			uvs[6] = new Vector2(1,1);
			uvs[7] = new Vector2(1,0);
			
			
			
			
			
			verts[4] = new Vector3(-scaler.x,-scaler.y,0);
			verts[5] = new Vector3(-scaler.x,scaler.y,0);
			verts[6] = new Vector3(scaler.x,scaler.y,0);
			verts[7] = new Vector3(scaler.x,-scaler.y,0);
			
			
			Mesh mesh = MeshUtils.makeMesh(name + "_picture", verts, uvs, inds);
			return mesh;
		}
		
		public static Mesh createBacking(Vector2 scaler, string name, bool correct)
		{
			Vector3 [] verts = new Vector3[4];
			Vector2 [] uvs = new Vector2[4];
			int[] inds = new int[6];
			inds[0] = 2;
			inds[1] = 1;
			inds[2] = 0;
			inds[3] = 0;
			inds[4] = 3;
			inds[5] = 2;

			float ratio = scaler.y/scaler.x;
			if (!correct)
				ratio = 1.0f;

			
			
			
			verts[0] = new Vector3(-scaler.x,-scaler.y,0);
			verts[1] = new Vector3(-scaler.x,scaler.y,0);
			verts[2] = new Vector3(scaler.x,scaler.y,0);
			verts[3] = new Vector3(scaler.x,-scaler.y,0);
			
			uvs[0] = new Vector2(verts[0].x,verts[0].y);
			uvs[1] = new Vector2(verts[1].x,verts[1].y);
			uvs[2] = new Vector2(verts[2].x,verts[2].y);
			uvs[3] = new Vector2(verts[3].x,verts[3].y);

			
			
			Mesh mesh = MeshUtils.makeMesh(name, verts, uvs, inds);
			return mesh;
		}

		public static Mesh createFrame(Vector2 scaler, List<Vector2> divides, string name)
		{
			if (divides[divides.Count-1].y != 0)
			{
				divides.Add(new Vector2(divides[divides.Count-1].x,0));
			}

			int numdiv = divides.Count;
			int numsegs = divides.Count;
			Vector3 [] verts = new Vector3[4*numsegs*4+4];
			Vector2 [] uvs = new Vector2[4*numsegs*4+4];
			
			Vector3 [] overts = new Vector3[4*numsegs];
			Vector2 [] ouvs = new Vector2[4*numsegs];

			int[] inds = new int[6*numsegs*4+6];
			Vector2 last = new Vector2(0,0);
			int countind = 0;
			int countvert = 0;


			Vector2 totaddl = new Vector2(-scaler.x,0);
			Vector2 totaddr = new Vector2(scaler.x,0);

			float len = 0;

			for (int i = 0; i < numdiv; ++i)
			{
				inds[0+countind] = 0+countvert;
				inds[1+countind] = 1+countvert;
				inds[2+countind] = 2+countvert;
				inds[3+countind] = 2+countvert;
				inds[4+countind] = 3+countvert;
				inds[5+countind] = 0+countvert;

				
				verts[0+countvert] = new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
				verts[1+countvert] = new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
				verts[2+countvert] = new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
				verts[3+countvert] = new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);

				Vector3 origl = verts[1+countvert];
				Vector3 origr = verts[2+countvert];

				Vector3 vecl = verts[0+countvert] - origl;
				Vector3 vecr = verts[3+countvert] - origr;


				Vector2 addl = new Vector2(vecl.x, new Vector2(vecl.y,vecl.z).magnitude);

				Vector2 addr = new Vector2(vecr.x, new Vector2(vecr.y,vecr.z).magnitude);

				uvs[0+countvert] = totaddl + addl;
				uvs[1+countvert] = totaddl;
				uvs[2+countvert] = totaddr;
				uvs[3+countvert] = totaddr + addr;
				totaddl += addl;
				totaddr += addr;

				countind += 6;
				countvert += 4;
				last = divides[i];
			}
			len = last.x;
			last = new Vector2(0,0);
			totaddl = new Vector2(-scaler.x+0.5f,0.1f);
			totaddr = new Vector2(scaler.x+0.5f,0.1f);
			for (int i = 0; i < numdiv; ++i)
			{
				inds[0+countind] = 2+countvert;
				inds[1+countind] = 1+countvert;
				inds[2+countind] = 0+countvert;
				inds[3+countind] = 0+countvert;
				inds[4+countind] = 3+countvert;
				inds[5+countind] = 2+countvert;
				
				
				verts[0+countvert] = new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
				verts[1+countvert] = new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
				verts[2+countvert] = new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
				verts[3+countvert] = new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);

				for (int j = 0; j < 4; ++j)
					verts[j+countvert].y = -verts[j+countvert].y;

				Vector3 origl = verts[1+countvert];
				Vector3 origr = verts[2+countvert];
				
				Vector3 vecl = verts[0+countvert] - origl;
				Vector3 vecr = verts[3+countvert] - origr;
				
				
				Vector2 addl = new Vector2(vecl.x, new Vector2(vecl.y,vecl.z).magnitude);
				
				Vector2 addr = new Vector2(vecr.x, new Vector2(vecr.y,vecr.z).magnitude);
				
				uvs[0+countvert] = totaddl + addl;
				uvs[1+countvert] = totaddl;
				uvs[2+countvert] = totaddr;
				uvs[3+countvert] = totaddr + addr;
				totaddl += addl;
				totaddr += addr;
				
				countind += 6;
				countvert += 4;
				last = divides[i];
			}

			
			last = new Vector2(0,0);
			totaddl = new Vector2(-scaler.y+0.65f,0.32f);
			totaddr = new Vector2(scaler.y+0.65f,0.32f);
			for (int i = 0; i < numdiv; ++i)
			{
				inds[0+countind] = 2+countvert;
				inds[1+countind] = 1+countvert;
				inds[2+countind] = 0+countvert;
				inds[3+countind] = 0+countvert;
				inds[4+countind] = 3+countvert;
				inds[5+countind] = 2+countvert;
				
				
				verts[0+countvert] = new Vector3(scaler.x+divides[i].x,-divides[i].x-scaler.y,divides[i].y);
				verts[1+countvert] = new Vector3(scaler.x+last.x,-last.x-scaler.y,last.y);
				verts[2+countvert] = new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
				verts[3+countvert] = new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);

				
				Vector3 origl = verts[1+countvert];
				Vector3 origr = verts[2+countvert];
				
				Vector3 vecl = verts[0+countvert] - origl;
				Vector3 vecr = verts[3+countvert] - origr;
				

				Vector2 addl = new Vector2(vecl.y, new Vector2(vecl.x,vecl.z).magnitude);
				
				Vector2 addr = new Vector2(vecr.y, new Vector2(vecr.x,vecr.z).magnitude);
				
				uvs[0+countvert] = totaddl + addl;
				uvs[1+countvert] = totaddl;
				uvs[2+countvert] = totaddr;
				uvs[3+countvert] = totaddr + addr;
				totaddl += addl;
				totaddr += addr;
				
				countind += 6;
				countvert += 4;
				last = divides[i];
			}
			
			last = new Vector2(0,0);
			totaddl = new Vector2(-scaler.y+0.65f,0.32f);
			totaddr = new Vector2(scaler.y+0.65f,0.32f);
			for (int i = 0; i < numdiv; ++i)
			{
				inds[0+countind] = 0+countvert;
				inds[1+countind] = 1+countvert;
				inds[2+countind] = 2+countvert;
				inds[3+countind] = 2+countvert;
				inds[4+countind] = 3+countvert;
				inds[5+countind] = 0+countvert;
				
				
				verts[0+countvert] = new Vector3(-scaler.x-divides[i].x,-divides[i].x-scaler.y,divides[i].y);
				verts[1+countvert] = new Vector3(-scaler.x-last.x,-last.x-scaler.y,last.y);
				verts[2+countvert] = new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
				verts[3+countvert] = new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
				
				
				Vector3 origl = verts[1+countvert];
				Vector3 origr = verts[2+countvert];
				
				Vector3 vecl = verts[0+countvert] - origl;
				Vector3 vecr = verts[3+countvert] - origr;
				
				
				Vector2 addl = new Vector2(vecl.y, new Vector2(vecl.x,vecl.z).magnitude);
				
				Vector2 addr = new Vector2(vecr.y, new Vector2(vecr.x,vecr.z).magnitude);
				
				uvs[0+countvert] = totaddl + addl;
				uvs[1+countvert] = totaddl;
				uvs[2+countvert] = totaddr;
				uvs[3+countvert] = totaddr + addr;
				totaddl += addl;
				totaddr += addr;
				
				countind += 6;
				countvert += 4;
				last = divides[i];
			}

			{
				
				inds[0+countind] = 2+countvert;
				inds[1+countind] = 1+countvert;
				inds[2+countind] = 0+countvert;
				inds[3+countind] = 0+countvert;
				inds[4+countind] = 3+countvert;
				inds[5+countind] = 2+countvert;
				
				
				verts[0+countvert] = new Vector3(scaler.x+len,scaler.y+len,0);
				verts[1+countvert] = new Vector3(-scaler.x-len,scaler.y+len,0);
				verts[2+countvert] = new Vector3(-scaler.x-len,-scaler.y-len,0);
				verts[3+countvert] = new Vector3(scaler.x+len,-scaler.y-len,0);

				for (int j = 0; j < 4; ++j)
				{
					uvs[j+countvert] = new Vector2(verts[j+countvert].x, verts[j+countvert].y);
				}
			}

			for (int i = 0; i < uvs.Length; ++i)
			{
				float temp = uvs[i].x;
				uvs[i].x = uvs[i].y;
				uvs[i].y = temp;
			}

			Mesh mesh = MeshUtils.makeMesh(name, verts, uvs, inds);
			return mesh;
		}

		
		public static List<string> getTextures(Material material){
			Shader shader=material.shader;
			List<string> materials=new List<string>();
			for (int i = 0; i < ShaderUtil.GetPropertyCount(shader) ; i++) {
				if (ShaderUtil.GetPropertyType(shader,i) == ShaderUtil.ShaderPropertyType.TexEnv){
					materials.Add((ShaderUtil.GetPropertyName(shader,i)));
				}
			}
			return materials;
		}
	}
}

