//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;

namespace PosterGen
{
	public static class MeshUtils{

        public class HalfEdge
        {
            public int[] index = new int[2];
            public int neighbor = -1;
        }
        public class Quad
        {
            public int[] edges = new int[4];
            public Color[] colors = new Color[4];
        }
        public class QuadMesh
        {
            public List<Quad> quads;
            public List<Vector3> vertices;
            public List<HalfEdge> edges;
        }

		public static void calculateMeshTangents(Mesh mesh)
		{
			//speed up math by copying the mesh arrays
			int[] triangles = mesh.triangles;
			Vector3[] vertices = mesh.vertices;
			Vector2[] uv = mesh.uv;
			Vector3[] normals = mesh.normals;
			
			//variable definitions
			int triangleCount = triangles.Length;
			int vertexCount = vertices.Length;
			
			Vector3[] tan1 = new Vector3[vertexCount];
			Vector3[] tan2 = new Vector3[vertexCount];
			
			Vector4[] tangents = new Vector4[vertexCount];
			
			for (long a = 0; a < triangleCount; a += 3)
			{
				long i1 = triangles[a + 0];
				long i2 = triangles[a + 1];
				long i3 = triangles[a + 2];
				
				Vector3 v1 = vertices[i1];
				Vector3 v2 = vertices[i2];
				Vector3 v3 = vertices[i3];
				
				Vector2 w1 = uv[i1];
				Vector2 w2 = uv[i2];
				Vector2 w3 = uv[i3];
				
				float x1 = v2.x - v1.x;
				float x2 = v3.x - v1.x;
				float y1 = v2.y - v1.y;
				float y2 = v3.y - v1.y;
				float z1 = v2.z - v1.z;
				float z2 = v3.z - v1.z;
				
				float s1 = w2.x - w1.x;
				float s2 = w3.x - w1.x;
				float t1 = w2.y - w1.y;
				float t2 = w3.y - w1.y;
				
				float r = 1.0f / (s1 * t2 - s2 * t1);
				
				Vector3 sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
				Vector3 tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
				
				tan1[i1] += sdir;
				tan1[i2] += sdir;
				tan1[i3] += sdir;
				
				tan2[i1] += tdir;
				tan2[i2] += tdir;
				tan2[i3] += tdir;
			}
			
			
			for (long a = 0; a < vertexCount; ++a)
			{
				Vector3 n = normals[a];
				Vector3 t = tan1[a];
				
				//Vector3 tmp = (t - n * Vector3.Dot(n, t)).normalized;
				//tangents[a] = new Vector4(tmp.x, tmp.y, tmp.z);
				Vector3.OrthoNormalize(ref n, ref t);
				tangents[a].x = t.x;
				tangents[a].y = t.y;
				tangents[a].z = t.z;
				
				tangents[a].w = (Vector3.Dot(Vector3.Cross(n, t), tan2[a]) < 0.0f) ? -1.0f : 1.0f;
			}
			
			mesh.tangents = tangents;
		}

		public static Mesh makeMesh(string name, Vector3 [] verts, Vector2[] uvs, int[] inds)
		{
			Mesh mesh = new Mesh();
			mesh.name = name;
			mesh.Clear();
			
			mesh.vertices = verts;
			mesh.uv = uvs;
			mesh.triangles = inds;
			
			mesh.Optimize();

			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			calculateMeshTangents(mesh);
			Unwrapping.GenerateSecondaryUVSet (mesh);
			return mesh;
		}
		public static GameObject createObjFrame(Mesh mesh, Texture2D tex, Shader ShaderToUse,
		                                   List<string> textureNames, List<Texture2D> texturesToUse,
		                                   float scalemaps)
		{
			GameObject obj = new GameObject(mesh.name, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider));
			MeshFilter mf = (MeshFilter)obj.gameObject.GetComponent(typeof(MeshFilter));
			
			MeshRenderer mr = (MeshRenderer)obj.gameObject.GetComponent(typeof(MeshRenderer));
			
			Material m = new Material(ShaderToUse);
			
			mr.GetComponent<Renderer>().material = m;

			for (int i = 0; i < textureNames.Count; ++i)
			{
				if (texturesToUse[i].width > 1 || texturesToUse[i].height > 1)
				{
					mr.GetComponent<Renderer>().sharedMaterial.SetTexture(textureNames[i], texturesToUse[i]);
					mr.GetComponent<Renderer>().sharedMaterial.SetTextureScale(textureNames[i], new Vector2(scalemaps,scalemaps));
				}
			} 
			
			mf.mesh = mesh;
			
			
			MeshCollider  col = (MeshCollider)obj.gameObject.GetComponent(typeof(MeshCollider));
			
			col.sharedMesh = mesh;//
			return obj;
		}
		public static GameObject createObj(Mesh mesh, Texture2D tex, Shader ShaderToUse,
		                            List<string> textureNames, List<Texture2D> texturesToUse,
		                            float scalemaps, Vector2 scaler)
		{
			GameObject obj = new GameObject(mesh.name, typeof(MeshFilter), typeof(MeshRenderer), typeof(MeshCollider));
			MeshFilter mf = (MeshFilter)obj.gameObject.GetComponent(typeof(MeshFilter));
			
			MeshRenderer mr = (MeshRenderer)obj.gameObject.GetComponent(typeof(MeshRenderer));
			
			Material m = new Material(ShaderToUse);
			
			mr.GetComponent<Renderer>().material = m;
			
			mr.GetComponent<Renderer>().sharedMaterial.SetTexture("_MainTex",tex);
			for (int i = 0; i < textureNames.Count; ++i)
			{
				if (textureNames[i] == "_MainTex")
					continue;
				if (texturesToUse[i].width > 1 || texturesToUse[i].height > 1)
				{
					mr.GetComponent<Renderer>().sharedMaterial.SetTexture(textureNames[i], texturesToUse[i]);
					mr.GetComponent<Renderer>().sharedMaterial.SetTextureScale(textureNames[i], new Vector2(scalemaps*(scaler.x*2.0f),scalemaps*(scaler.y*2.0f)));
				}
			} 
			
			mf.mesh = mesh;
			
			
			MeshCollider  col = (MeshCollider)obj.gameObject.GetComponent(typeof(MeshCollider));
			
			col.sharedMesh = mesh;//
			return obj;
		}
		
		public static Mesh convertTexToMesh(Vector2 scaler, string name)
		{
			Vector3 [] verts = new Vector3[8];
			Vector2 [] uvs = new Vector2[8];
			int[] inds = new int[12];
			inds[0] = 2;
			inds[1] = 1;
			inds[2] = 0;
			inds[3] = 0;
			inds[4] = 3;
			inds[5] = 2;
			inds[6] = 0+4;
			inds[7] = 1+4;
			inds[8] = 2+4;
			inds[9] = 2+4;
			inds[10] = 3+4;
			inds[11] = 0+4;
			
			uvs[0] = new Vector2(0,0);
			uvs[1] = new Vector2(0,1);
			uvs[2] = new Vector2(1,1);
			uvs[3] = new Vector2(1,0);
			
			
			
			
			verts[0] = new Vector3(-scaler.x,-scaler.y,0.005f);
			verts[1] = new Vector3(-scaler.x,scaler.y,0.005f);
			verts[2] = new Vector3(scaler.x,scaler.y,0.005f);
			verts[3] = new Vector3(scaler.x,-scaler.y,0.005f);
			
			
			
			uvs[4] = new Vector2(0,0);
			uvs[5] = new Vector2(0,1);
			uvs[6] = new Vector2(1,1);
			uvs[7] = new Vector2(1,0);
			
			
			
			
			
			verts[4] = new Vector3(-scaler.x,-scaler.y,0.005f);
			verts[5] = new Vector3(-scaler.x,scaler.y,0.005f);
			verts[6] = new Vector3(scaler.x,scaler.y,0.005f);
			verts[7] = new Vector3(scaler.x,-scaler.y,0.005f);
			
			
			Mesh mesh = MeshUtils.makeMesh(name + "_picture", verts, uvs, inds);
			return mesh;
		}
		
		public static Mesh createBacking(Vector2 scaler, string name, bool correct)
		{
			Vector3 [] verts = new Vector3[4];
			Vector2 [] uvs = new Vector2[4];
			int[] inds = new int[6];
			inds[0] = 2;
			inds[1] = 1;
			inds[2] = 0;
			inds[3] = 0;
			inds[4] = 3;
			inds[5] = 2;

			float ratio = scaler.y/scaler.x;
			if (!correct)
				ratio = 1.0f;

			
			
			
			verts[0] = new Vector3(-scaler.x,-scaler.y,0.000f);
			verts[1] = new Vector3(-scaler.x,scaler.y,0.000f);
			verts[2] = new Vector3(scaler.x,scaler.y,0.000f);
			verts[3] = new Vector3(scaler.x,-scaler.y,0.000f);
			
			uvs[0] = new Vector2(verts[0].x,verts[0].y);
			uvs[1] = new Vector2(verts[1].x,verts[1].y);
			uvs[2] = new Vector2(verts[2].x,verts[2].y);
			uvs[3] = new Vector2(verts[3].x,verts[3].y);

			
			
			Mesh mesh = MeshUtils.makeMesh(name, verts, uvs, inds);
			return mesh;
		}

        public static QuadMesh generateQuads(Vector2 scaler, List<Vector2> divides)
        {
            QuadMesh quads = new QuadMesh();

            for (int i = 0; i < divides.Count; ++i)
            {
                Vector3 x0y0 = new Vector3(-scaler.x - divides[i].x, -divides[i].x - scaler.y, divides[i].y);
                Vector3 x0y1 = new Vector3(-scaler.x - divides[i].x, divides[i].x + scaler.y, divides[i].y);
                Vector3 x1y0 = new Vector3(scaler.x + divides[i].x, -divides[i].x - scaler.y, divides[i].y);
                Vector3 x1y1 = new Vector3(scaler.x + divides[i].x, divides[i].x + scaler.y, divides[i].y);
                quads.vertices.Add(x0y0);
                quads.vertices.Add(x0y1);
                quads.vertices.Add(x1y0);
                quads.vertices.Add(x1y1);

                HalfEdge e0 = new HalfEdge();
                HalfEdge e1 = new HalfEdge();
                HalfEdge e2 = new HalfEdge();
                HalfEdge e3 = new HalfEdge();

                e0.index[0] = i * 4 + 1;
                e0.index[1] = i * 4 + 3;

                e1.index[0] = i * 4 + 0;
                e1.index[1] = i * 4 + 2;

                e2.index[0] = i * 4 + 2;
                e2.index[1] = i * 4 + 3;

                e3.index[0] = i * 4 + 0;
                e3.index[1] = i * 4 + 1;


                quads.edges.Add(e0);
                quads.edges.Add(e1);
                quads.edges.Add(e2);
                quads.edges.Add(e3);

                Quad q0 = new Quad();
                Quad q1 = new Quad();
                Quad q2 = new Quad();
                Quad q3 = new Quad();
            }
            return quads;
        }
		public static Mesh createFrame(Vector2 scaler, List<Vector2> divides, string name)
		{
			if (divides[divides.Count-1].y != 0)
			{
				divides.Add(new Vector2(divides[divides.Count-1].x,0));
			}
			
			int numdiv = divides.Count;
			int numsegs = divides.Count;
			Vector3 [] verts = new Vector3[4*numsegs*4+4];
			Vector2 [] uvs = new Vector2[4*numsegs*4+4];
			Color[] colors = new Color[4 * numsegs * 4 + 4];
			
			int[] inds = new int[6*numsegs*4+6];
			int countind = 0;
			int countvert = 0;
			HalfEdge[] edges = new HalfEdge[numdiv*4];
			Vector3 [] points = new Vector3[numdiv * 4];
			
			for (int i = 0; i < numdiv; ++i)
			{
				Vector3 x0y0 = new Vector3(-scaler.x-divides[i].x,-divides[i].x-scaler.y,divides[i].y);
				Vector3 x0y1 = new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
				Vector3 x1y0 = new Vector3(scaler.x+divides[i].x,-divides[i].x-scaler.y,divides[i].y);
				Vector3 x1y1 = new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);
				points[i*4+0] = x0y0;
				points[i*4+1] = x0y1;
				points[i*4+2] = x1y0;
				points[i*4+3] = x1y1;
				
				edges[i*4] = new HalfEdge();
				edges[i*4].index[0] = i*4+1;
				edges[i*4].index[1] = i*4+3;
				
				edges[i*4+1] = new HalfEdge();
				edges[i*4+1].index[0] = i*4+0;
				edges[i*4+1].index[1] = i*4+2;
				
				edges[i*4+2] = new HalfEdge();
				edges[i*4+2].index[0] = i*4+2;
				edges[i*4+2].index[1] = i*4+3;
				
				edges[i*4+3] = new HalfEdge();
				edges[i*4+3].index[0] = i*4+0;
				edges[i*4+3].index[1] = i*4+1;
			}
			
			float len = divides[divides.Count-1].x;
			Vector2 totaddl = new Vector2(-scaler.x - divides[0].x,0);
			Vector2 totaddr = new Vector2(scaler.x + divides[0].x,0);
            for (int i = 1; i < numdiv; ++i)
            {
                inds[0 + countind] = 0 + countvert;
                inds[1 + countind] = 1 + countvert;
                inds[2 + countind] = 2 + countvert;
                inds[3 + countind] = 2 + countvert;
                inds[4 + countind] = 3 + countvert;
                inds[5 + countind] = 0 + countvert;

                verts[0 + countvert] = points[edges[i * 4].index[0]];//new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
                verts[1 + countvert] = points[edges[(i - 1) * 4].index[0]];//new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
                verts[2 + countvert] = points[edges[(i - 1) * 4].index[1]];//new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
                verts[3 + countvert] = points[edges[i * 4].index[1]];//new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);

                Vector3 origl = verts[1 + countvert];
                Vector3 origr = verts[2 + countvert];

                Vector3 vecl = verts[0 + countvert] - origl;
                Vector3 vecr = verts[3 + countvert] - origr;


                Vector2 addl = new Vector2(vecl.x, new Vector2(vecl.y, vecl.z).magnitude);
                Vector2 addr = new Vector2(vecr.x, new Vector2(vecr.y, vecr.z).magnitude);

                uvs[0 + countvert] = totaddl + addl;
                uvs[1 + countvert] = totaddl;
                uvs[2 + countvert] = totaddr;
                uvs[3 + countvert] = totaddr + addr;
                totaddl += addl;
                totaddr += addr;

                countind += 6;
                countvert += 4;
            }

            totaddl = new Vector2(-scaler.x - divides[0].x, 0.0f);
            totaddr = new Vector2(scaler.x + divides[0].x, 0.0f);
            for (int i = 1; i < numdiv; ++i)
            {
                inds[0 + countind] = 2 + countvert;
                inds[1 + countind] = 1 + countvert;
                inds[2 + countind] = 0 + countvert;
                inds[3 + countind] = 0 + countvert;
                inds[4 + countind] = 3 + countvert;
                inds[5 + countind] = 2 + countvert;



                verts[0 + countvert] = points[edges[i * 4 + 1].index[0]];//new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
                verts[1 + countvert] = points[edges[(i - 1) * 4 + 1].index[0]];//new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
                verts[2 + countvert] = points[edges[(i - 1) * 4 + 1].index[1]];//new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
                verts[3 + countvert] = points[edges[i * 4 + 1].index[1]];//new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);



                Vector3 origl = verts[1 + countvert];
                Vector3 origr = verts[2 + countvert];

                Vector3 vecl = verts[0 + countvert] - origl;
                Vector3 vecr = verts[3 + countvert] - origr;


                Vector2 addl = new Vector2(vecl.x, new Vector2(vecl.y, vecl.z).magnitude);
                Vector2 addr = new Vector2(vecr.x, new Vector2(vecr.y, vecr.z).magnitude);

                uvs[0 + countvert] = totaddl + addl;
                uvs[1 + countvert] = totaddl;
                uvs[2 + countvert] = totaddr;
                uvs[3 + countvert] = totaddr + addr;
                totaddl += addl;
                totaddr += addr;

                countind += 6;
                countvert += 4;
            }


            totaddl = new Vector2(-scaler.y - divides[0].x, 0.0f);
            totaddr = new Vector2(scaler.y + divides[0].x, 0.0f);

            for (int i = 1; i < numdiv; ++i)
            {
                inds[0 + countind] = 2 + countvert;
                inds[1 + countind] = 1 + countvert;
                inds[2 + countind] = 0 + countvert;
                inds[3 + countind] = 0 + countvert;
                inds[4 + countind] = 3 + countvert;
                inds[5 + countind] = 2 + countvert;


                verts[0 + countvert] = points[edges[i * 4 + 2].index[0]];//new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
                verts[1 + countvert] = points[edges[(i - 1) * 4 + 2].index[0]];//new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
                verts[2 + countvert] = points[edges[(i - 1) * 4 + 2].index[1]];//new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
                verts[3 + countvert] = points[edges[i * 4 + 2].index[1]];//new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);


                Vector3 origl = verts[1 + countvert];
                Vector3 origr = verts[2 + countvert];

                Vector3 vecl = verts[0 + countvert] - origl;
                Vector3 vecr = verts[3 + countvert] - origr;


                Vector2 addl = new Vector2(vecl.y, new Vector2(vecl.x, vecl.z).magnitude);

                Vector2 addr = new Vector2(vecr.y, new Vector2(vecr.x, vecr.z).magnitude);

                uvs[0 + countvert] = totaddl + addl;
                uvs[1 + countvert] = totaddl;
                uvs[2 + countvert] = totaddr;
                uvs[3 + countvert] = totaddr + addr;
                totaddl += addl;
                totaddr += addr;

                countind += 6;
                countvert += 4;
            }

            totaddl = new Vector2(-scaler.y - divides[0].x, 0.0f);
            totaddr = new Vector2(scaler.y + divides[0].x, 0.0f);
            for (int i = 1; i < numdiv; ++i)
            {
                inds[0 + countind] = 0 + countvert;
                inds[1 + countind] = 1 + countvert;
                inds[2 + countind] = 2 + countvert;
                inds[3 + countind] = 2 + countvert;
                inds[4 + countind] = 3 + countvert;
                inds[5 + countind] = 0 + countvert;



                verts[0 + countvert] = points[edges[i * 4 + 3].index[0]];//new Vector3(-scaler.x-divides[i].x,divides[i].x+scaler.y,divides[i].y);
                verts[1 + countvert] = points[edges[(i - 1) * 4 + 3].index[0]];//new Vector3(-scaler.x-last.x,last.x+scaler.y,last.y);
                verts[2 + countvert] = points[edges[(i - 1) * 4 + 3].index[1]];//new Vector3(scaler.x+last.x,last.x+scaler.y,last.y);
                verts[3 + countvert] = points[edges[i * 4 + 3].index[1]];//new Vector3(scaler.x+divides[i].x,divides[i].x+scaler.y,divides[i].y);

                Vector3 origl = verts[1 + countvert];
                Vector3 origr = verts[2 + countvert];

                Vector3 vecl = verts[0 + countvert] - origl;
                Vector3 vecr = verts[3 + countvert] - origr;


                Vector2 addl = new Vector2(vecl.y, new Vector2(vecl.x, vecl.z).magnitude);
                Vector2 addr = new Vector2(vecr.y, new Vector2(vecr.x, vecr.z).magnitude);

                uvs[0 + countvert] = totaddl + addl;
                uvs[1 + countvert] = totaddl;
                uvs[2 + countvert] = totaddr;
                uvs[3 + countvert] = totaddr + addr;
                totaddl += addl;
                totaddr += addr;

                countind += 6;
                countvert += 4;
            }

			{
				
				inds[0+countind] = 2+countvert;
				inds[1+countind] = 1+countvert;
				inds[2+countind] = 0+countvert;
				inds[3+countind] = 0+countvert;
				inds[4+countind] = 3+countvert;
				inds[5+countind] = 2+countvert;
				
				
				verts[0+countvert] = new Vector3(scaler.x+len,scaler.y+len,-0.00f);
				verts[1+countvert] = new Vector3(-scaler.x-len,scaler.y+len,-0.00f);
				verts[2+countvert] = new Vector3(-scaler.x-len,-scaler.y-len,-0.00f);
				verts[3+countvert] = new Vector3(scaler.x+len,-scaler.y-len,-0.00f);

				for (int j = 0; j < 4; ++j)
				{
					uvs[j+countvert] = new Vector2(verts[j+countvert].x, verts[j+countvert].y);
				}
			}

			for (int i = 0; i < uvs.Length; ++i)
			{
				float temp = uvs[i].x;
				uvs[i].x = uvs[i].y;
				uvs[i].y = temp;
			}

			Mesh mesh = MeshUtils.makeMesh(name, verts, uvs, inds);
			return mesh;
		}

		
		public static List<string> getTextures(Material material){
			Shader shader=material.shader;
			List<string> materials=new List<string>();
			for (int i = 0; i < ShaderUtil.GetPropertyCount(shader) ; i++) {
				if (ShaderUtil.GetPropertyType(shader,i) == ShaderUtil.ShaderPropertyType.TexEnv){
					materials.Add((ShaderUtil.GetPropertyName(shader,i)));
				}
			}
			return materials;
		}
	}
}

