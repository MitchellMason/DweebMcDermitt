//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using UnityEditor;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
namespace PosterGen
{
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[RequireComponent(typeof(MeshCollider))]
	public class PosterGenUtils
	{
		
		public Options options;
		public bool createPictures()
		{
			Object[] objects = Selection.GetFiltered(typeof(Texture2D), SelectionMode.DeepAssets);
			
			if (objects.Length <= 0)
			{
				return false;
			}
			
			GameObject root = new GameObject("Pictures");

			FrameGen fgs = root.AddComponent<FrameGen>();
			fgs.isPoster = false;
			PosterGroup pgs = root.AddComponent<PosterGroup>();
			pgs.options = options;
			Undo.RegisterCreatedObjectUndo(root, "Created Pictures");

			float transform = 0;
			Vector2 last = new Vector2(0,0);

			for (int i = 0; i < objects.Length; ++i)
			{
				Object obj = objects[i];
				{
					string path = AssetDatabase.GetAssetPath(obj);
					
					TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
					TextureImporterNPOTScale npot = textureImporter.npotScale;   
					textureImporter.npotScale = TextureImporterNPOTScale.None;   
					bool readable = textureImporter.isReadable;
					textureImporter.isReadable = true;

					AssetDatabase.ImportAsset(path);
					
					
					Texture2D tex = (Texture2D)obj;
					Texture2D newTex = tex;
					float wide = tex.width;
					float high = tex.height;
					float ratio = high/wide;
					/*
					if (options.fadeout)
					{
						string dir = Application.dataPath + "/" + "PosterGenImages";
						if (!Directory.Exists(dir))
							Directory.CreateDirectory(dir);
						pather = dir + "/" + tex.name + "_Poster" + ".png";
						newTex = new Texture2D(tex.width, tex.height, TextureFormat.RGBA32, true);
						
						for (int j = 0; j < newTex.width; ++j)
						{
							for (int k = 0; k < newTex.height; ++k)
							{
								float fade = 1.0f;
								float fadeout = options.border/100.0f;

								float width = newTex.width;
								float height = newTex.height;
								float x = j;
								float y = k;

								float maxEdgex = Mathf.Min ((x-1.0f)/width,1.0f-(x+1.0f)/width);
								float maxEdgey = Mathf.Min ((y-1.0f)/height,1.0f-(y+1.0f)/height);
								float maxEdge = Mathf.Min(maxEdgex, maxEdgey);
								if (maxEdge < fadeout)
									fade = maxEdge/fadeout;

								fade = Mathf.Max (fade,0.0f);
								Color col = tex.GetPixel(j,k);
								newTex.SetPixel(j,k,new Color(col.r,col.g,col.b,fade));


							}
						}
						{
							byte [] bytes = newTex.EncodeToPNG();


							File.WriteAllBytes(pather, bytes);

						}
					}
					*/
					textureImporter.isReadable = readable;
					textureImporter.npotScale = npot;   
					AssetDatabase.ImportAsset(path);  
					/*
					if (options.fadeout)
					{
						AssetDatabase.ImportAsset(pather);
						newTex.LoadImage(File.ReadAllBytes(pather));
					}
					*/
					Vector2 scaler = new Vector2(1.0f, ratio);
					
					float curarea = scaler.x*scaler.y;
					
					float adj = options.area/curarea;
					
					if (options.usemax)
					{
						if (scaler.x > options.maxdim)
						{
							scaler /= scaler.x/options.maxdim;
						}
						if (scaler.y > options.maxdim)
						{
							scaler /= scaler.y/options.maxdim;
						}
					}
					scaler *= Mathf.Sqrt(adj);
					
					transform += last.x + scaler.x;
					transform += options.offset;



					newTex.alphaIsTransparency = true;

					
					
					GameObject picture = MeshUtils.createObj(MeshUtils.convertTexToMesh(scaler,tex.name + "_picture"),
					                                         newTex, options.ShaderToUse,
					                                         options.textureNames, options.texturesToUse,
					                                         options.scalemaps, scaler); 
					Material temp = (picture.GetComponent<MeshRenderer>() as MeshRenderer).sharedMaterial;
					
					temp.SetTextureScale(options.textureNames[0], new Vector2(-1,1));
					picture.transform.parent = root.transform;

					{
						if (!options.overlap)
						{
							picture.transform.Translate(new Vector3(transform,options.rise,0));
						}
						FrameGen fg = picture.AddComponent<FrameGen>() as FrameGen;
						
						fg.scaler = scaler;
						fg.rotate = new Vector3(0,0,0);


					}

					last = scaler;
				}
				
			}
			return true;
		}


	}
}

	